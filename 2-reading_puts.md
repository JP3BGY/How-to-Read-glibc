# puts()を読んでみよう

## puts()を見つけよう

puts()を読み始めるためにはまずputs()がどこで宣言されているか見つけなくてはならない。そのための方法をいくつか紹介する。

* デバッグシンボルから場所を特定する

[読み始める前に](1-introduction.md)でインストールしたデバッグシンボルを用いてソースがどこにあるのかを特定する。まず、以下のようなプログラムを書きコンパイルをしよう。ここではプログラム本体のデバッグを目的とはしていないので```-g```オプションを付ける必要はない。
```C
#include <stdio.h>
int main(){
  puts("Hello!!");
}
```
その後、GDBでプログラムを起動し、以下のようなコマンドを実行する。
```gdb
tui enable
b puts
r
```
そうすると、puts()にはいったところでプログラムが止まるのでそのファイル名を確認してソースコードに対して```find ./ -name filename.c```などで検索をかけたり、そのままGDBで読み進めれば良いと思う。
デバッガを使う利点は関数がシステムや設定によって宣言場所が違う場合に、自分の環境ではどれが使われているのかがすぐに分かるという点である。また、デバッグシンボルが使えるものならばすべてのソフトウェアで対応できる手法なので最初はこれで見つけ出すのが一番早いであろう。
難点としてはデバッグシンボルがない、または何らかの理由でデバッグすることができない場合は使えないというところであろう。しかし、今現在UbuntuとFedoraではパッケージマネージャから多くのデバッグシンボルをインストールできるので、その範囲内のソフトウェアなら特に問題とはならない。

* ナビゲーションシステムから探す。

各ナビゲーションシステムにあるシンボル検索や関数検索から検索する。ここではwoboqとSourceWebで動作を確認したがどちらも正しいところを示している。
こちらの利点はソースがあれば問題なくできるところ、いちいちソフトウェアを起動する必要がないのでMySQLやLinuxといった複雑なソフトウェアでも問題なく読めることであろう。欠点はそこまで結果に対して信用できないことである。一応WoboqやSourceWebやDXRはC/C++の場合はコンパイラを通しているらしいがgccではないので一部のgcc拡張には対応できないし、いくつかシンボルを検知できていないものも散見される。最終的にはやはりgrepを使うことになる。

* ソースコードの構造から当たりをつけて見つける

これはある程度ソースコードを読み慣れないとできないことだが、慣れればこれが一番良いと思われる。なぜなら、今回は標準ライブラリを読むという点からたまたま読みたい関数を指定することができたが一般にソフトウェアのリーディングをする場合はどの関数を読めばいいかなんてものは知ることができないからである。せいぜい特定の機能に関する部分というところまでしか絞ることができない。その場合は当たりをつけるということが非常に重要になる。ここではそのあたりの付け方について記す。

まず、glibcのトップのファイル構造を見てみよう。以下のリンクか自身がダウンロードしたディレクトリで```ls```を実行してみよう。以下のような結果になる。
https://code.woboq.org/userspace/glibc/
```

```
